#include "dataflash.h"
#include "Global.h"
#include "stm32f10x.h"
sys_dataflash_t  SaveData;

uint16_t Flash_Write_Without_check(uint32_t iAddress, uint8_t *buf, uint16_t iNumByteToWrite) {
    uint16_t i;
    volatile FLASH_Status FLASHStatus = FLASH_COMPLETE;
    i = 0;
    
    FLASH_UnlockBank1();
    while((i < iNumByteToWrite) && (FLASHStatus == FLASH_COMPLETE))
    {
      FLASHStatus = FLASH_ProgramHalfWord(iAddress, *(uint16_t*)buf);
      i = i+2;
      iAddress = iAddress + 2;
      buf = buf + 2;
    }
    
    return iNumByteToWrite;
}
/**
  * @brief  Programs a half word at a specified Option Byte Data address.
  * @note   This function can be used for all STM32F10x devices.
  * @param  Address: specifies the address to be programmed.
  * @param  buf: specifies the data to be programmed.
  * @param  iNbrToWrite: the number to write into flash
  * @retval if success return the number to write, -1 if error
  *  
  */
int Flash_Write(uint32_t iAddress, uint8_t *buf, uint32_t num) 
{
	/* Unlock the Flash Bank1 Program Erase controller */
	uint32_t secpos;
	uint32_t iNumByteToWrite = num;
	uint16_t secoff;
	uint16_t secremain;  
	uint16_t i = 0;    
	uint8_t tmp[FLASH_PAGE_SIZE];
	
	volatile FLASH_Status FLASHStatus = FLASH_COMPLETE;
	
	FLASH_Unlock();
 
	secpos = iAddress & (~(FLASH_PAGE_SIZE -1 )) ;//扇区地址 
	secoff = iAddress & (FLASH_PAGE_SIZE -1);     //在扇区内的偏移
	secremain = FLASH_PAGE_SIZE-secoff;           //扇区剩余空间大小 
	

	if(iNumByteToWrite<=secremain) secremain = iNumByteToWrite;//不大于4096个字节

	while( 1 ) 
	{
		Flash_Read(secpos, tmp, FLASH_PAGE_SIZE);   //读出整个扇区
		for(i=0;i<secremain;i++) 
		{       //校验数据
			if(tmp[secoff+i]!=0XFF)break;       //需要擦除 
		}
		if(i<secremain) 
		{  //需要擦除
			FLASHStatus = FLASH_ErasePage(secpos); //擦除这个扇区
			
			if(FLASHStatus != FLASH_COMPLETE)
				return -1;
				
			for(i=0;i<secremain;i++) 
			{   //复制
				tmp[i+secoff]=buf[i];   
			}
			Flash_Write_Without_check(secpos ,tmp ,FLASH_PAGE_SIZE);//写入整个扇区  
		} 
		else 
		{
			Flash_Write_Without_check(iAddress,buf,secremain);//写已经擦除了的,直接写入扇区剩余区间.
		}

		if(iNumByteToWrite==secremain) //写入结束了
			break;
		else 
		{
			secpos += FLASH_PAGE_SIZE;
			secoff = 0;//偏移位置为0 
			buf += secremain;  //指针偏移
			iAddress += secremain;//写地址偏移    
			iNumByteToWrite -= secremain;  //字节数递减
			if(iNumByteToWrite>FLASH_PAGE_SIZE) 
				secremain=FLASH_PAGE_SIZE;//下一个扇区还是写不完
			else 
				secremain = iNumByteToWrite;  //下一个扇区可以写完了
		}

	}
					
	FLASH_Lock();
	return num; 
}






/**
  * @brief  Programs a half word at a specified Option Byte Data address.
  * @note   This function can be used for all STM32F10x devices.
  * @param  Address: specifies the address to be programmed.
  * @param  buf: specifies the data to be programmed.
  * @param  iNbrToWrite: the number to read from flash
  * @retval if success return the number to write, without error
  *  
  */
int Flash_Read(uint32_t iAddress, uint8_t *buf, int32_t num) 
{
	int i = 0;

	while(i < num ) 
	{
		*(buf + i) = *(__IO uint8_t*) iAddress++;
		i++;
	}
	return i;
}





void init_data_save(void)
{
	uint8_t flag = 0;
	sys_dataflash_t data_init;
	int i,j;
	
	Flash_Read(FLASH_SAVE_BASE_ADD, &flag, 1);
	if(flag != 0x10)
	{
		for(i = 0; i < 2; i ++)
		{
			for(j = 0; j < 3; j++)
			{
				data_init.mag_param[j][i] = 0;
			}
		}
		flag = 0x10;
		Flash_Write(FLASH_SAVE_BASE_ADD, &flag, 1);
		Flash_Write(FLASH_SAVE_BASE_ADD + 2, (uint8_t * )&data_init, sizeof(sys_dataflash_t));
		
	}
	//Flash_Read(FLASH_SAVE_BASE_ADD + 2, (uint8_t * )&SaveData, sizeof(sys_dataflash_t));
	data_read();
	Delay_ms(20);
}


void data_save(void)
{
	int i, j;
	for(i = 0; i < 2; i ++)
	{
		for(j = 0; j < 3; j++)
		{
			SaveData.mag_param[j][i] = mag_param[j][i];
		}
	}
	
	Flash_Write(FLASH_SAVE_BASE_ADD + 2, (uint8_t * )&SaveData, sizeof(sys_dataflash_t));
}


void data_read(void)
{
	int i , j;
	Flash_Read(FLASH_SAVE_BASE_ADD + 2, (uint8_t * )&SaveData, sizeof(sys_dataflash_t));
	
	for(i = 0; i < 2; i ++)
	{
		for(j = 0; j < 3; j ++)
		{
			mag_param[j][i] = SaveData.mag_param[j][i];
		}
	}
}


























